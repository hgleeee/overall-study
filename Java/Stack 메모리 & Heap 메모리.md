# Stack 메모리 & Heap 메모리
> 자바는 기본 자료형(primary type)을 제외하고 다른 모든 것을 레퍼런스(포인터 참조값)으로 사용한다. 즉 힙 메모리를 사용한다는 뜻인데, 왜 이렇게 만들었고 스택, 힙 메모리를 구분지어 사용하는 이유는 무엇일까?

## 1. 프로그램의 메모리 할당
- C와 같은 고급 언어로 작성된 프로그램 코드를 바로 실행 가능한 명령어(.exe)로 바꾸는 과정은 다음과 같다.
<p align="center"><img src="../images/compile_process.jpg" width="600"></p>

- 이를 조금 더 큰 그림으로 보게되면 아래와 같은데

```
1. 사용자가 운영체제에 프로그램 실행을 요청하고
2. 운영체제는 프로세스를 만들고 메모리를 할당하게 된다.
3. 이 때, 프로세스마다 할당되는 메모리는 Code, Data, Heap, Stack 영역으로 효율적으로 나누어 사용한다.
```

<p align="center"><img src="../images/memory_allocation.png" width="600"></p>

<p align="center"><img src="../images/memory_allocation_2.png" width="600"></p>

## 2. 자바의 메모리 할당
<p align="center"><img src="../images/java_process.jpg" width="600"></p>

- 자바 코드는 기계어가 아닌 바이트 코드로 번역되고 JVM을 거쳐서 실행된다.
- 그래서 프로그램에 실행에 필요한 데이터를 JVM에서 받아와 제공하긴 하지만, 큰 그림으로 봤을 때의 메모리 구조는 크게 다르지 않다.
- Runtime Data Area에서 필요한 메모리를 운영체제로부터 할당받으면 JVM 내부에서 Method(=Data), Stack, Heap, Native-Method, PC-register로 메모리를 나누어 사용한다.

<p align="center"><img src="../images/java_memory_struct.jpg" width="600"></p>

- Method Area : 모든 Thread에 공유 되는 정적인 전역 데이터이다. 클래스나 변수의 정보, Static변수, 상수등이 저장된다.
- Heap Area : 모든 Thread에 공유되며 인스턴스와 객체가 저장되는 구역이다. (레퍼런스 참조, new 키워드)
- Stack Area : 각 스레드마다 전용 스택 메모리가 존재한다. 지역변수, 파라메타, 리턴 값등이 저장된다.
- PC Register : 각 스레드마다 하나씩 생성되며 Program Counter의 역할을 담당한다. (현재 실행중인 메모리 주소 값) 자바에서는 CPU 독립성을 위해 레지스터기반이 아닌 스택기반으로 프로그램 명령이 동작함을 알아두자.
- Native Method Stack : 각 스레드마다 하나씩 생성되며 다른 언어의 네이티브 메서드를 호출하기 위한 공간이다. 
 
 


Java 코드가 JVM을 통해 사용하는 메모리 구조.
# 2-1 Stack 메모리
설명을 읽어보면 알겠지만, Java의 JVM에서 스택 메모리는 정적인 메모리 할당 및 각각 스레드 공간에서 따로 실행된다. 이는 스택 구조로 저장되며 새로운 메서드가 호출되면 스택 맨위에 새로운 블럭(Stack Frame)을 생성하여 각 객체나 메서드마다 필요한 지역변수들을 저장한다. 그리고 메서드가 실행을 마치면 스택 블럭(Stack Frame)을 비우는 방식이다.

 

새로운 메서드가 호출되고 반환될 때 마다 스택의 크기가 달라진다.
스택 내부의 변수는 해당 메서드(=스레드)가 실행되는 동안에만 존재한다.
메소드 실행이 완료되면 자동으로 스택에서 할당 해제된다.
각 스레드가 고유의 스택 메모리를 가지고 있으므로 다른 스레드로부터 안전한 메모리를 가진다.
이러한 스택 구조의 메모리 접근은 힙 메모리에 비해 속도가 빠르다.
왜 빠르죠?
더보기
 

# 2-2 Heap 메모리
Stack이 컴파일 타임에 크기가 지정되는 정적인 메모리공간이라면, Heap은 런타임에 동적으로 할당하는 메모리이다. 자바에서 새로운 객체는 항상 힙 공간에 생성되고, 이 객체에 대한 참조 주소는 스택 메모리(변수)에 저장되어 사용된다.

 

Heap에서 만든 메모리는 모든 스레드에서 참조, 접근 가능하기 때문에 메모리 누수가 발생하기 쉽다. 그래서 메모리 할당&해제 관리에 있어 어려움이 따르는데 이를 JVM의 Gabage Collector가 개발자 대신 관리해준다.

 

GC의 Young Generation, Tenured(Old) Generation, Permanent Generation을 포함하는 복잡한 메모리 관리 기술에 의해 메모리를 관리, 사용 할 수 있다.
운영체제에게 할당받은 힙 공간이 가득차 메모리가 부족하면 OutOfMemoryError를 발생시킨다.
Heap은 스레드로 부터 안전하지 않으며 코드를 적절하게 동기화하여 메모리를 보호해야한다.
메모리 공간이 정적이지 않고, 크기가 변할수 있기에 메모리 할당과 접근이 스택보다 느리고 어렵다.
스택은 독립적인 스레드에서 실행되고 스택포인터 값을 변경함으로써 메모리 공간이 자동으로 해제 되지만, Heap에서는 누구나 메모리를 참조 할 수 있고 메모리 공간이 유동적이라 자동으로 할당 해제되지 않는다.
이러한 동적인 메모리 사용은 메모리 단편화가 생길 수 있고, 정기적으로 사용하지 않는 메모리를 찾아 해제해야 한다.


