# 트랜잭션 (Transaction)
> 하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합

## ACID (트랜잭션이 가지는 4가지 성질)
### Atomicity (원자성)
- 이체 과정 중에 트랜잭션이 실패하게 되어 예금이 사라지는 경우가 발생해서는 안 된다.
  - 따라서, DBMS는 완료되지 않은 트랜잭션의 중간 상태를 데이터베이스에 반영해서는 안 된다.
- 즉, 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다. Atomicity는 쉽게 __'all or nothing'__ 특성으로 설명된다.

### Consistency (일관성)
- 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다. 즉, 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다.
- 트랜잭션의 수행을 데이터베이스 상태 간의 전이(transition)로 봤을 때, 트랜잭션 수행 전후의 데이터베이스 상태는 각각 일관성이 보장되는 서로 다른 상태가 된다.
- 트랜잭션 수행이 보존해야 할 일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들뿐만 아니라, 자금 이체 예에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있다.

### Isolation (고립성)
- 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다.
- 한 트랜잭션에서 데이터베이스를 변경한 내용은 트랜잭션이 커밋되기 전까지는 다른 어떤 질의나 트랜잭션과도 고립되어야만 한다. 즉, 각 트랜잭션은 시스템 내에서 동시에 수행되고 있는 다른 트랜잭션들을 알지 못한다.
  - 한 트랜잭션의 중간 결과가 다른 트랜잭션에게는 숨겨져야 한다는 의미인데, 이러한 isolation 성질이 보장되지 않으면 트랜잭션이 원래 상태로 되돌아갈 수 없게 된다.
- DBMS의 병행 제어 모듈이 트랜잭션의 고립성을 보장한다.

### Durability (지속성)
- 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.
- 데이터베이스 시스템은 데이터베이스의 현재 상태가 유실되지 않도록 시스템 충돌 등의 문제로부터 복구할 수 있는 방법을 갖추고 있어야 한다.
- DBMS의 복구 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장한다.

<p align="center"><img src="../images/db_transaction_acid.png" width="600"></p>


## 트랜잭션의 상태
<p align="center"><img src="../images/db_transaction_state.png" width="600"></p>

#### 활동(Active)
- 트랜잭션이 실행 중인 상태

#### 실패(Failed) 
- 트랜잭션 실행에 오류가 발생하여 중단된 상태

#### 철회(Aborted) 
- 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

#### 부분 완료(Partially Committed) 
- 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

#### 완료(Committed) 
- 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

#### Commit
- Commit 연산은 한 개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

#### Rollback
- 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산
- Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.


## 병행 제어 (Concurrency Control)
- 대부분의 DBMS들은 다수 사용자용이기 때문에, 동시에 여러 사용자들이 동일 테이블에 접근하기도 한다.
  - DBMS의 성능을 높이기 위해 여러 사용자의 질의나 프로그램들을 동시에 수행하는 것이 필수적
- 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션을 동시에 수행하는 환경에서 서로 간의 간섭이 생기지 않도록 한다. (부정확한 결과 도출 방지)
- 직렬 스케줄(Serial Schedule) : 여러 트랜잭션들을 한 트랜잭션씩 차례대로 수행 (병렬이 아님)
- 비직렬 스케줄(Non-serial Schedule) : 여러 트랜잭션들을 동시에 수행 (일관성을 보장하지 못함)

- __직렬 가능(Serializable)__ : 비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행 결과와 동등하다.

### 병행 제어를 하지 않고 다수의 트랜잭션을 동시에 수행한다면?

#### Lost Update (갱신 손실)
<p align="center"><img src="../images/db_lost_update.png" width="500"></p>

- 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효가 되는 것이다.

#### Dirty Read (더티 읽기)
<p align="center"><img src="../images/db_dirty_read.png" width="500"></p>

- 완료되지 않은 트랜잭션이 갱신한 데이터 내용을 읽으려고 할 때 발생한다.
#### Unrepeatable Read (반복할 수 없는 읽기)
<p align="center"><img src="../images/db_unrepeatable_read.png" width="500"></p>

- 한 트랜잭션이 동일한 데이터를 두 번 읽을 때, 서로 다른 값을 읽는 것이다.
- 다른 트랜잭션이 데이터에 접근하여 수정해버렸고, 결국 isolation level이 지켜지지 않은 것이다.

## 복구 (Recovery)
- 여러 애플리케이션이 주기억장치 버퍼 내의 동일한 데이터베이스 항목을 갱신한 후에 디스크에 기록하는 것이 Disk I/O 작업을 줄일 수 있어 성능 향상에 도움이 된다.
  - 즉, 버퍼의 내용을 디스크에 기록하는 것을 최대한 줄이는 것이 일반적이다.

### REDO
- 커밋한 트랜잭션의 수정은 어떤 경우에도 유지(durability)되어야 한다. 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업을 REDO 복구라고 한다.
- 만일 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행했다면, 복구 모듈은 이 트랜잭션의 갱신 사항을 REDO(재수행)하여 트랜잭션의 갱신이 지속성을 갖도록 해야 한다.
### UNDO
- 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못했다면, 원자성을 보장하기 위해 이 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 UNDO(취소)해야 한다.
- UNDO 복구와 REDO 복구를 위해서 가장 널리 쓰이는 구조는 로그(log)이다.






