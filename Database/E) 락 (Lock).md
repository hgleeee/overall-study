# 락 (Lock)
- 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해 널리 사용되는 기법

## 특징
- 대부분의 로킹 관련 작업은 사용자가 신경쓸 필요 없이, DBMS에서 모두 이루어진다.
- 로킹 단위가 크면 관리하기가 용이(로킹 오버헤드 감소), 하지만 동시성 수준이 낮아진다.
- 로킹 단위가 작으면 동시성 수준이 높아지지만 관리가 까다롭다. (로킹 오버헤드 증가)

## 종류
### 독점 로크 (X-lock, eXclusive lock)
- 한 데이터 항목에 대한 갱신은 한 트랜잭션에 대해서만 허용되므로, 트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때는 독점 로크를 요청

### 공유 로크 (S-lock, Shared lock)
- 트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 때는 공유 로크를 요청

## 2단계 로킹 프로토콜 (2-phase lock protocol)
- 로크를 요청하는 것과 로크를 해제하는 것, 2단계로 이루어진다.
  - 로크 확장 단계가 지난 후에 로크 수축 단계에 들어감
  - 일단 로크를 한 개라도 해제하면 로크 수축 단계에 들어감
- 자기가 사용할 데이터 전체에 lock을 걸 때까지는 해제를 못한다. 로크를 걸 게 더 이상 없을 때부터 해제를 할 수 있다.
  - 마찬가지로, 해제하는 단계에서는 새로 lock을 걸 수 없다.

### 로크 확장 단계(1단계)
- 로크 확장 단계에서는 트랜잭션이 데이터 항목에 대하여 새로운 로크를 요청할 수 있지만, 보유하고 있던 로크를 하나라도 해제할 수 없음

### 로크 수축 단계(2단계) 
- 로크 수축 단계에서는 보유하고 있던 로크를 해제할 수 있지만 새로운 로크를 요청할 수 없다.
- 로크 수축 단계에서는 로크를 조금씩 해제할 수도 있고, 트랜잭션이 완료 시점에 이르렀을 때 한꺼번에 모든 로크를 해제할 수도 있음 (일반적으로 한꺼번에 해제하는 방식 필요)
  - 한꺼번에 해제함으로써 cascade rollback 등의 문제를 원천적으로 차단할 수 있다.

### 로크 포인트(lock point)
- 한 트랜잭션에서 필요로 하는 모든 로크를 걸어놓은 시점

## 데드록(deadlock)
- 2단계 로킹 프로토콜에서는 데드록이 발생할 수 있다.
- 데드록은 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 lock를 요청하면서 기다리고 있는 상태를 말한다.
- 데드록을 해결하기 위해서는 데드록을 방지하는 기법이나, 데드록을 탐지하고 희생자를 선정하여 데드록을 푸는 기법 등을 사용한다. (victim을 process kill)

## 다중 로크 단위(multiple granularity)
- 다수의 트랜잭션들이 소수의 tuple에 접근하는 데이터베이스에서는 tuple 단위로 로크해도 로크 테이블을 다루는 시간이 오래 걸리지 않는다.
- 반대로, 트랜잭션들이 다수의 tuple에 접근하는 데이터베이스에서 tuple 단위로만 로크를 한다면 로크 테이블에서 로크 충돌을 검사하고, 로크 정보를 기록하는 시간이 오래 걸린다.
- 트랜잭션이 접근하는 tuple의 수에 따라 로크하는 데이터 항목의 단위를 구분하는 것이 필요하다.
- 한 트랜잭션에서 로크할 수 있는 데이터 항목이 두 가지 이상 있으면 다중 로크 단위라고 말함
  - 데이터베이스에서 로크할 수 있는 단위로는 데이터베이스, 릴레이션, 디스크 블록, 투플 등
- 일반적으로 DBMS는 각 트랜잭션에서 접근하는 tuple 수에 따라 자동적으로 로크 단위를 조정함
  - 로크 단위가 작을수록 로킹에 따른 오버헤드 증가
  - 로크 단위가 작을수록 동시성의 정도 증가 (수많은 트랜잭션들의 동시성)

## 트랜잭션과 Lock
- Lock과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.
- Lock은 여러 커넥션에서 동시에 동일 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 여기서 자원은 레코드나 테이블을 말한다.
- 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다.
  - 트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다.
  - 예를 들면 HW 에러 또는 SW 에러와 같은 문제로 인해 작업에 실패가 있을 경우, 특별한 대책이 필요하게 되는데 이러한 문제를 해결하는 것이다.
- 트랜잭션에서도 DeadLock이 발생할 수 있다.
